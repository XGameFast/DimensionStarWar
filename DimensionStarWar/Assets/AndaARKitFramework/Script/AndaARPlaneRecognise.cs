using System.Collections; using System.Collections.Generic; using GoogleARCore; using UnityEngine; using UnityEngine.XR.iOS; public class AndaARPlaneRecognise : MonoBehaviour {     public LayerMask collisionLayerMask;     public float findingSquareDist = 0.5f;     public float maxRayDistance = 30.0f;     public float timeLimit = 2.5f;     public AndaFocusPlane andaFocusPlane;     public AndaARWorldController aRWorldController;      private bool isCheckingPlane = false;      private Vector3 lasterHitPose;     private float lasterShakeValue;     private float loadTime = -1f;     private bool isSetARAnchor = false;     private System.Action<Vector3, Quaternion,bool> FinishCallBack;     private System.Action ResetARAnchor;     private bool isFinishChecking = false;      private bool isResetEvent =false;      public Transform VirtualGround;       public void OnDisable()
    {
        isResetEvent = false;
    }      public void StartRecognise(System.Action<Vector3, Quaternion ,bool> callback, System.Action callbackReset)     {         FinishCallBack = callback;         ResetARAnchor = callbackReset;         InitValue();     }      private void InitValue()     {                 isCheckingPlane = false;         isSetARAnchor = false;          //isResetEvent = false; 不能放在初始化，如果是重置的，会有记录的          loadTime = -1;         lasterShakeValue = -1;         andaFocusPlane.gameObject.SetTargetActiveOnce(false);         isFinishChecking = false;     }      public void OnUpdate()     {         if(isFinishChecking)return;          if(JIRVIS.Instance.jIRVISData.isSupportAR)         {               #if UNITY_EDITOR             EditorCheckHitPlane();             #elif !UNITY_EDITOR && UNITY_IOS                     IOSCheckHitPlane();         #else //安卓                     AndroidCheckHitPlane();         #endif         }else         {             VirtualARCheckHitPlane();         }              }      private void AndroidCheckHitPlane()     {          TrackableHit hit;         TrackableHitFlags raycastFilter = TrackableHitFlags.PlaneWithinPolygon | TrackableHitFlags.FeaturePoint;         if (Frame.Raycast(Screen.width / 2,Screen.height / 2, raycastFilter, out hit))         {             if ((hit.Trackable is DetectedPlane) && Vector3.Dot(ARMonsterSceneDataManager.Instance.arCameraPosition - hit.Pose.position,hit.Pose.rotation * Vector3.up) < 0)             {                 Debug.Log("Hit at back of the current DetectedPlane");             }             else             {                 Vector3 pose = hit.Pose.position;                                  var anchor = hit.Trackable.CreateAnchor(hit.Pose);                 VirtualGround.gameObject.SetTargetActiveOnce(true);                 VirtualGround.transform.parent = anchor.transform;                 VirtualGround.transform.position = pose;                 EditorCheckHitPlane();                                 //andaFocusPlane.transform.position = pose;                 //andaFocusPlane.transform.rotation = Quaternion.LookRotation(ARMonsterSceneDataManager.Instance.FaceToCameraWithSeflY(andaFocusPlane.transform.position));//  hit.transform.rotation;                 //andaFocusPlane.transform.parent = anchor.transform;                 //andaFocusPlane.gameObject.SetTargetActiveOnce(true);                 //Load();             }         }else         {             VirtualGround.gameObject.SetTargetActiveOnce(false);         }     }      private void IOSCheckHitPlane()     {          //Debug.Log("IOSChecking!!!!!!!!!!!!");         Vector3 center = new Vector3(Screen.width / 2, Screen.height / 2, findingSquareDist);         Vector3 screenPosition = ARMonsterSceneDataManager.Instance.mainCamera.ScreenToViewportPoint(center);         ARPoint point = new ARPoint         {             x = screenPosition.x,             y = screenPosition.y         } ;          ARHitTestResultType[] resultTypes = {             ARHitTestResultType.ARHitTestResultTypeFeaturePoint,             ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,             //ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent,              // if you want to use infinite planes use this:             //ARHitTestResultType.ARHitTestResultTypeExistingPlane,             //ARHitTestResultType.ARHitTestResultTypeHorizontalPlane,              //ARHitTestResultType.ARHitTestResultTypeFeaturePoint         };         foreach(var go in resultTypes)         {                         List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface().HitTest(point, go);             if (hitResults.Count > 0)             {                 foreach (var hitResult in hitResults)                 {                     Vector3 pose = UnityARMatrixOps.GetPosition(hitResult.worldTransform);                     VirtualGround.gameObject.SetTargetActiveOnce(true);                     VirtualGround.transform.position = pose;                      EditorCheckHitPlane();                     //Quaternion rose = UnityARMatrixOps.GetRotation(hitResult.worldTransform);                   //  andaFocusPlane.transform.position = pose;                     //andaFocusPlane.transform.rotation = rose;                   //   andaFocusPlane.transform.rotation = Quaternion.LookRotation(ARMonsterSceneDataManager.Instance.FaceToCameraWithSeflY(andaFocusPlane.transform.position));//  hit.transform.rotation;                     //  andaFocusPlane.gameObject.SetTargetActiveOnce(true);                   //  Load();                 }             }else             {                 VirtualGround.gameObject.SetTargetActiveOnce(false);             }         }       //    andaFocusPlane.gameObject.SetTargetActiveOnce(HitTestWithResultType(point,ARHitTestResultType.ARHitTestResultTypeFeaturePoint));     }      private void VirtualARCheckHitPlane()     {         EditorCheckHitPlane();
    }      private void EditorCheckHitPlane()     {          Vector3 center = new Vector3(Screen.width / 2, Screen.height / 2, findingSquareDist);         Ray ray = ARMonsterSceneDataManager.Instance.mainCamera.ScreenPointToRay(center);         RaycastHit hit;         if (Physics.Raycast(ray, out hit, maxRayDistance, collisionLayerMask))         {              //we're going to get the position from the contact point             andaFocusPlane.transform.position = hit.point;             //and the rotation from the transform of the plane collider             andaFocusPlane.transform.rotation = Quaternion.LookRotation(ARMonsterSceneDataManager.Instance.FaceToCameraWithSeflY(andaFocusPlane.transform.position));//  hit.transform.rotation;              andaFocusPlane.gameObject.SetTargetActiveOnce(true);                        Load();         }         else         {             andaFocusPlane.gameObject.SetActive(false);         }     }      private void Load()     {         if(!isCheckingPlane)         {             AndaGameExtension.ImpactFeedbackStyleLight();             loadTime = Time.time;             isCheckingPlane =true;         }          if(Vector3.Distance(lasterHitPose , andaFocusPlane.transform.position)> 0.25f)         {             loadTime = Time.time;             lasterHitPose = andaFocusPlane.transform.position;             return;         }         float deltaTime = Time.time - loadTime;         float per = deltaTime / timeLimit;         per = Mathf.Clamp01(per);         andaFocusPlane.SetValue(1 - per);         float t = Vector3.Distance(andaFocusPlane.transform.position, ARMonsterSceneDataManager.Instance.mainCamera.transform.position);         andaFocusPlane.UpdateDistanceMesh(t);         if(per >= 1)         {             andaFocusPlane.gameObject.SetTargetActiveOnce(false);             isSetARAnchor = true;             isFinishChecking = true;             CallBackFinishCheck();             VirtualGround.gameObject.SetTargetActiveOnce(false);             //isCheckingPlane =false;         }     }       public void SetVirtualGround(Vector3 pose)     {         VirtualGround.position = pose;     }        private void CallBackFinishCheck()     {         if (FinishCallBack != null)         {             FinishCallBack(andaFocusPlane.transform.position,andaFocusPlane.transform.rotation,isResetEvent);         }     }      private void ClickRestartSetARAnchorPose()     {         //正在检测，不能使用摇一摇去重制         if (isCheckingPlane) return;         //在没有设置锚点的时候，不能使用摇一摇重制         if (!isSetARAnchor) return;         if(Input.GetMouseButtonDown(0))         {             lasterShakeValue += 1;         }         if(lasterShakeValue>5)         {             isResetEvent = true;             ResetARAnchor();         }      }      private void ShakeRestartSetARAnchorPose()     {         //正在检测，不能使用摇一摇去重制         if (isCheckingPlane) return;         //在没有设置锚点的时候，不能使用摇一摇重制         if (!isSetARAnchor) return;         float shakex = Input.acceleration.x;         if(lasterShakeValue!=-1 && Mathf.Abs(shakex - lasterShakeValue) > 0.8f)         {             isResetEvent = true;             ResetARAnchor();         }         lasterShakeValue = shakex;     }  }